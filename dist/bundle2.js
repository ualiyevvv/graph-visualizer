(()=>{"use strict";let t=new class{constructor(){this.nodes=new Map}addNode(t){this.nodes.has(t)||this.nodes.set(t,new Set)}addEdge(t,s){if(!this.nodes.has(t)||!this.nodes.has(s))throw new Error("Both nodes must be added to the graph before adding an edge.");this.nodes.get(t).add(s),this.nodes.get(s).add(t)}removeNode(t){if(this.nodes.has(t)){for(let s of this.nodes.get(t))this.nodes.get(s).delete(t);this.nodes.delete(t)}}removeEdge(t,s){this.nodes.has(t)&&this.nodes.has(s)&&(this.nodes.get(t).delete(s),this.nodes.get(s).delete(t))}getNeighbors(t){return this.nodes.has(t)?Array.from(this.nodes.get(t)):[]}hasNode(t){return this.nodes.has(t)}hasEdge(t,s){return this.nodes.has(t)&&this.nodes.get(t).has(s)}};["A","Av","Ab","An","Ak","Aj","Ah","Ag","Af","As","As1","As2","As3","As4","As5","As52"].map((s=>t.addNode(s))),[["A","Av"],["A","Ak"],["A","Ah"],["A","Af"],["A","Aj"],["Ak","Ab"],["Ak","An"],["Ak","As2"],["Ak","As"],["Ak","Ag"],["Af","As4"],["Af","As3"],["Af","As1"],["Af","As52"],["Af","As5"]].map((s=>t.addEdge(s[0],s[1])));let s=new class{MIN_X=-1e3;MIN_Y=-1e3;MAX_X=1e3;MAX_Y=1e3;MIN_SCALE=.1;MAX_SCALE=10;ZOOM_FACTOR=1.1;constructor(t,s){this.WIDTH=window.innerWidth,this.HEIGHT=window.innerHeight,this.graph=t,this.canvas=document.getElementById(s),this.ctx=this.canvas.getContext("2d"),this.canvas.width=this.WIDTH,this.canvas.height=this.HEIGHT,this.nodePositions=new Map,this.animationFrameRequest=null,this.repulsionForce=80,this.attractionForce=.1,this.lastMoveTimestamp=0,this.moveThrottleInterval=20,this.windowCenter={x:this.WIDTH/2,y:this.HEIGHT/2},this.scale=1,this.offsetX=0,this.offsetY=0,this.zoomDelta=1,this.startX=0,this.startY=0,this.isDragging=!1,this.draggingNode=null,this.#t(),this.initializeMouseEvents()}startAnimation(){this.animationFrameRequest=!0;const t=()=>{this.animationFrameRequest&&(console.log("animation"),this.updateNodePositions(),this.draw(),requestAnimationFrame(t))};t()}start(){const t=Math.min(1,1)/2,s=this.graph.nodes.size;let e=2*Math.PI/s,i=0;for(let s of this.graph.nodes.keys()){let h=i*e;this.nodePositions.set(s,{x:1+t*Math.cos(h),y:1+t*Math.sin(h)}),i++}this.startAnimation()}drawGraph(){this.ctx.strokeStyle="black";for(let[t,s]of this.graph.nodes)s.forEach((s=>{this.nodePositions.has(t)&&this.nodePositions.has(s)&&(this.ctx.beginPath(),this.ctx.moveTo(this.nodePositions.get(t).x,this.nodePositions.get(t).y),this.ctx.lineTo(this.nodePositions.get(s).x,this.nodePositions.get(s).y),this.ctx.stroke())}));this.ctx.fillStyle="red",this.ctx.fillRect(-25,-25,50,50),this.ctx.fillStyle="blue",this.ctx.fillRect(1e3,1e3,50,50),this.ctx.fillRect(-1e3,1e3,50,50),this.ctx.fillRect(-1e3,-1e3,50,50),this.ctx.fillRect(1e3,-1e3,50,50);for(let[t,s]of this.nodePositions)this.ctx.fillStyle="red",this.ctx.beginPath(),this.ctx.arc(s.x,s.y,10,0,2*Math.PI),this.ctx.fill(),this.ctx.fillStyle="blue",this.ctx.textAlign="center",this.ctx.textBaseline="middle",this.ctx.fillText(t,s.x,s.y)}draw(){this.ctx.save(),this.ctx.clearRect(0,0,this.WIDTH,this.HEIGHT),this.ctx.setTransform(this.scale,0,0,this.scale,this.windowCenter.x,this.windowCenter.y),this.ctx.translate(this.offsetX,this.offsetY),this.drawGraph(),this.#s(),this.zoomDelta=1,this.ctx.restore()}updateNodePositions(){for(let[t,s]of this.nodePositions){let e=0,i=0;for(let[h,o]of this.nodePositions)if(t!==h){let t=s.x-o.x,h=s.y-o.y,a=Math.sqrt(t*t+h*h);if(a>0){let s=this.repulsionForce/a;e+=s*t/a,i+=s*h/a}}for(let h of this.graph.getNeighbors(t))if(this.nodePositions.has(h)){let t=this.nodePositions.get(h),o=t.x-s.x,a=t.y-s.y;e+=this.attractionForce*o,i+=this.attractionForce*a}s.x+=e,s.y+=i}}initializeMouseEvents(){this.canvas.addEventListener("wheel",(t=>this.handleZoom(t))),this.canvas.addEventListener("mousedown",(t=>this.handleMouseDown(t))),this.canvas.addEventListener("mousemove",(t=>this.handleMouseMove(t))),this.canvas.addEventListener("mouseup",(t=>this.handleMouseUp(t)))}handleMouseDown(t){const s=parseInt((t.clientX-this.canvas.offsetLeft-this.windowCenter.x)/this.scale)+-this.offsetX,e=parseInt((t.clientY-this.canvas.offsetTop-this.windowCenter.y)/this.scale)+-this.offsetY;for(let[t,i]of this.nodePositions){const h=s-i.x,o=e-i.y;if(h*h+o*o<100){this.draggingNode=t,console.log(t);break}}this.isDragging=!0,this.startX=t.clientX,this.startY=t.clientY,console.log("x:",s,"y:",e)}handleMouseMove(t){if(this.draggingNode){const s=this.nodePositions.get(this.draggingNode);s.x=t.offsetX,s.y=t.offsetY,this.startAnimation()}else if(this.isDragging){const s=(t.clientX-this.startX)/this.scale,e=(t.clientY-this.startY)/this.scale;this.offsetX+=s,this.offsetY+=e,this.offsetX<this.MIN_X&&(this.offsetX=this.MIN_X),this.offsetX>this.MAX_X&&(this.offsetX=this.MAX_X),this.offsetY<this.MIN_Y&&(this.offsetY=this.MIN_Y),this.offsetY>this.MAX_Y&&(this.offsetY=this.MAX_Y),this.startX=t.clientX,this.startY=t.clientY,this.draw()}}handleMouseUp(){parseInt((event.clientX-this.canvas.offsetLeft-this.windowCenter.x)/this.scale),this.offsetX,parseInt((event.clientY-this.canvas.offsetTop-this.windowCenter.y)/this.scale),this.offsetY,this.draggingNode=null,this.isDragging=!1}zoom(t){this.zoomDelta=t>0?this.ZOOM_FACTOR:1/this.ZOOM_FACTOR,this.scale*=this.zoomDelta,this.scale<this.MIN_SCALE&&(this.scale=this.MIN_SCALE),this.scale>this.MAX_SCALE&&(this.scale=this.MAX_SCALE),this.draw()}handleZoom(t){const s=Math.max(-1,Math.min(1,t.wheelDelta||-t.detail));this.zoom(s)}#s(){const t=new URLSearchParams(window.location.search);t.set("scale",this.scale.toFixed(1)),t.set("offsetX",parseInt(this.offsetX)),t.set("offsetY",parseInt(this.offsetY)),window.history.replaceState({},"",`${window.location.pathname}?${t}`)}#t(){const t=new URLSearchParams(window.location.search);this.scale=parseFloat(t.get("scale"))||this.scale,this.offsetX=parseInt(t.get("offsetX"))||this.offsetX,this.offsetY=parseInt(t.get("offsetY"))||this.offsetY}stop(){this.animationFrameRequest&&(cancelAnimationFrame(this.animationFrameRequest),this.animationFrameRequest=null)}}(t,"graphCanvas");s.start()})();